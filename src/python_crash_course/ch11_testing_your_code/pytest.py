# 测试代码：在编写函数或类时，还可为其编写测试。
# 通过测试，可确定代码面对各种输入都能够按要求工作。
# 测试让你坚信，无论有多少人使用你的程序，它都将正确地工作。
# 在程序中添加新代码时，也可对其进行测试，确认它们不会破坏程序既有的行为。
# 程序员都会犯错，因此每个程序员都必须经常测试自己的代码，先于用户发现问题。
# 在本章中，将学习如何使用 pytest 来测试代码。
# pytest 库是一组工具，不仅能帮助快速而轻松地编写测试，而且能持续支持随项目增大而变得复杂的测试。
# Python 默认不包含 pytest，因此将学习如何安装外部库。
# 知道如何安装外部库让你能够使用各种设计良好的代码。
# 这些库还极大地增加了可开发的项目类型。
# 将学习编写测试用例，核实一系列输入都将得到预期的输出。
# 将看到测试通过了是什么样子的，测试未通过又是什么样子的，还将知道测试未通过如何有助于改进代码。
# 将学习如何测试函数和类，以及该为项目编写多少个测试。

# 使用 pip 安装 pytest：虽然 Python 通过标准库提供了大量的功能，但 Python 开发人员还是需要频繁用到第三方包。
# 第三方包（third-party package）指的是独立于Python 核心的库。
# 有些深受欢迎的第三方包最终会被纳入标准库，并从此随Python 一起被安装。
# 通常，能被纳入标准库的包在消除最初的 bug 后不会发生太多变化，它们在被纳入后只能与 Python 语言同步演进。
# 然而，很多包并未被纳入标准库，因此得以独立于 Python 语言本身的更新计划。
# 相较于纳入标准库，独立的第三方包的更新频率往往更高，pytest 和本书第二部分将使用的大部分库属于这种情况。
# 虽然不应盲目信任所有的第三方包，但也不要因噎废食，因为很多重要的功能是使用第三方包实现的。

# 更新 pip：Python 提供了一款名为 pip 的工具，可用来安装第三方包。
# 因为 pip 帮我们安装来自外部的包，所以更新频繁，以消除潜在的安全问题。
# 有鉴于此，先来更新 pip。打开一个终端窗口，执行如下命令：
# $ python -m pip install --upgrade pip
# Requirement already satisfied: pip in ./.pyenv/versions/3.11.9/lib/python3.11/site-packages (24.0)
# --snip--
# Successfully installed pip-25.1.1
# 这个命令的第一部分（python -m pip）让 Python 运行 pip 模块；第二部分让 pip 更新一个已安装的包；而最后一部分指定要更新哪个第三方包。
# 输出表明，当前的 pip 版本（24.0）被替换成了最新的版本（25.1.1）。
# 可使用下面的命令更新系统中安装的任何包：
# $ python -m pip install --upgrade package_name
# 如果使用的是 Linux，在安装 Python 时可能不会自动安装 pip。

# 安装 pytest：将 pip 升级到最新版本后，就可以安装 pytest 了。
# $ python -m pip install --user pytest
# Collecting pytest
# --snip--
# Successfully installed iniconfig-2.1.0 packaging-25.0 pluggy-1.6.0 pygments-2.19.2 pytest-8.4.1
# 这里使用的核心命令也是 pip install，但指定的标志不是 --upgrade，而是 --user。
# 这个标志让 Python 只为当前用户安装指定的包。
# 输出表明，成功地安装了最新版本的 pytest，以及 pytest 运行所需的多个其他包。
# 可使用下面的命令安装众多的第三方包：
# python -m pip install --user package_name
# 如果在执行这个命令时遇到麻烦，可尝试在不指定标志 --user 的情况下再次执行它。

# 测试函数：
# 要学习测试，必须有要测试的代码。下面是一个简单的函数，定义在 name_function.py 中，它接受名和姓并返回格式规范的姓名：
def get_formatted_name(first, last):
    """生成格式规范的姓名"""
    full_name = f"{first} {last}"
    return full_name.title()


# get_formatted_name() 函数将名和姓合并成姓名，在名和姓之间加上一个空格并将首字母大写，然后返回结果。
# 为了核实 get_formatted_name() 会像期望的那样工作，编写一个使用这个函数的程序。
# 程序 names.py 让用户输入名和姓，并显示格式规范的姓名：
# 这个程序从 name_function.py 中导入 get_formatted_name()。
# 用户可输入一系列名和姓，并看到格式规范的姓名：
"""
Enter 'q' at any time to quit. 
 
Please give me a first name: janis 
Please give me a last name: joplin 
       Neatly formatted name: Janis Joplin.

Please give me a first name: q
"""
# 从上述输出可知，合并得到的姓名正确无误。
# 现在假设要修改 get_formatted_name()，使其还能够处理中间名。
# 在添加这项功能时，要确保不破坏这个函数处理只有名和姓的姓名的方式。
# 为此，可在每次修改 get_formatted_name() 后都进行测试：运行程序 names.py，并输入像 Janis Joplin 这样的姓名。
# 不过这太烦琐了。所幸 pytest 提供了一种自动测试函数输出的高效方式。
# 倘若对 get_formatted_name() 进行自动测试，就能始终确信，当给这个函数提供测试过的姓名时，它都能正确地工作。

# 单元测试和测试用例：软件的测试方法多种多样。
# 一种最简单的测试是单元测试（unit test），用于核实函数的某个方面没有问题。
# 测试用例（test case）是一组单元测试，这些单元测试一道核实函数在各种情况下的行为都符合要求。
# 良好的测试用例考虑到了函数可能收到的各种输入，包含针对所有这些情况的测试。
# 全覆盖（full coverage）测试用例包含一整套单元测试，涵盖了各种可能的函数使用方式。
# 对于大型项目，要进行全覆盖测试可能很难。
# 通常，最初只要针对代码的重要行为编写测试即可，等项目被广泛使用时再考虑全覆盖。

# 可通过的测试：使用 pytest 进行测试，会让单元测试编写起来非常简单。
# 将编写一个测试函数，它会调用要测试的函数，并做出有关返回值的断言。
# 如果断言正确，表示测试通过；如果断言不正确，表示测试未通过。
# 这个针对 get_formatted_name() 函数的测试在 test_name_function.py 中：
# 在运行这个测试前，先来仔细观察一下。
# 测试文件的名称很重要，必须以 test_ 打头。
# 当让 pytest 运行测试时，它将查找以 test_ 打头的文件，并运行其中的所有测试。
# 在这个测试文件中，首先导入要测试的 get_formatted_name() 函数。
# 然后，定义一个测试函数 test_first_last_name()。这个函数名比以前使用的都长，原因有二。
# 第一，测试函数必须以 test_ 打头。
# 在测试过程中，pytest 将找出并运行所有以 test_ 打头的函数。
# 第二，测试函数的名称应该比典型的函数名更长，更具描述性。
# 你自己不会调用测试函数，而是由 pytest 替你查找并运行它们。
# 因此，测试函数的名称应足够长，让你在测试报告中看到它们时，能清楚地知道它们测试的是哪些行为。
# 接下来，调用要测试的函数。
# 像运行 names.py 时一样，这里在调用 get_formatted_name() 函数时向它传递了实参 'janis' 和 'joplin'。
# 将这个函数的返回值赋给变量 formatted_name。最后，做出一个断言。
# 断言（assertion）就是声称满足特定的条件：这里声称 formatted_name 的值为 'Janis Joplin'。

# 断言是一种调试辅助工具，它用于检查一个条件是否为真。
# 如果条件为真，程序将继续正常执行；如果条件为假，程序将立即停止，并引发一个 AssertionError 异常。
# 它的核心思想是：“我断定这里的某个条件必须是真的，如果不是，那我的程序就已经处于一个非预期的、错的状态，必须立即停止，防止造成更大的破坏。”
# 断言使用 assert 关键字，语法非常简单：
# assert <条件表达式>[, <可选的错误信息>]
# <条件表达式>: 这是一个求值结果为布尔值（True 或 False）的表达式。
# <可选的错误信息>: 这是一个字符串或者任何可以被打印的对象。
# 当断言失败时，这个信息会被包含在 AssertionError 中，能帮助更快地理解问题所在。
# 断言机制的核心：__debug__ 常量。
# 理解断言的关键在于 __debug__ 这个特殊的内置常量。
# Python 解释器在正常模式下启动时，__debug__ 的值是 True。
# assert 语句在内部其实等同于下面的代码：
"""
if __debug__:
    if not <条件表达式>:
        raise AssertionError(<可选的错误信息>)
"""
# 这意味着：断言只在 __debug__ 为 True 的时候才会生效。
# 可以在启动 Python 解释器时使用 -O（大写的 O，代表 "Optimize"）选项来关闭断言。
# 当使用 -O 选项时，解释器会将 __debug__ 的值设为 False。
# 这样一来，所有的 assert 语句都会被完全跳过，不会执行任何判断，也就没有任何性能开销。
# 由于断言可以被关闭，因此必须遵循一个黄金法则：
# 绝对不要用 assert 来做程序正常逻辑中必须的用户输入校验或数据验证。
# 因为一旦程序在生产环境以 -O 模式运行，这些校验就全部失效了！
# 正确的应用场景是：
# 检查函数的前置条件和后置条件 (契约式设计)：
# 检查传入函数的参数是否符合预期。
# 检查函数返回的结果是否在有效范围内。
# 检查代码中的不变量：
# 在复杂的算法或流程中，检查某个中间状态是否一直保持预期的那样。
# 作为代码逻辑的“文档”：
# assert 语句本身就能清晰地告诉其他开发者（或未来的你），在这里代码的状态应该是怎样的。
# 生成环境要用 if condition: raise SomeError() 来确保程序的健壮性和用户体验。

# 单元测试、集成测试等各种测试场景是 assert 最理想的用武之地。
# 测试框架（如 pytest）就大量使用 assert 来判断测试用例是否通过。
# assert 的核心哲学是一种开发阶段的“安全网”。
# 开发者用它来确保自己的代码逻辑在任何时候都严格遵守自己的假设。
# 我们相信，经过充分的测试，这些内部逻辑在上线后是不会出错的，所以可以安全地关闭它们以提升性能。
# 任何无法100%控制的事情，尤其是外部输入（用户输入、文件内容、网络数据），都绝不能使用 assert。
# 因为这些错误是程序正常运行中可预见的、必须处理的一部分。如果用 assert，在生产环境 (-O模式) 下就相当于完全不设防。

# 既然 if 更保险，为什么还要用 assert？
# 目的和“语义”完全不同：代码即文档：
# assert 和 if 向阅读代码的人传达了完全不同的信息。
# if condition: 的意思是：“这种情况是可能发生的，我们需要在这里检查并处理它。” 它描述的是程序的正常或异常流程。
# assert condition: 的意思是：“我（开发者）断言这种情况永远不应该发生。
# 如果它发生了，那一定是我的代码里有Bug，整个程序的内部状态已经不可信了，必须立即崩溃，不要继续错下去。” 它描述的是程序的逻辑“契约”或不变量。
# 使用 assert 能让代码的意图更清晰，它是一种强有力的文档，告诉后来者：“注意，这里的这个条件是代码正确性的基石，不应该被违反。”
# 性能开销：可以被“一键关闭”的调试开关：
# 在一些对性能要求极高的场景（例如科学计算、游戏引擎、金融高频交易），成千上万的内部检查会累积成不可忽视的性能开销。
# assert 机制提供了一个非常优雅的解决方案：在开发和测试时，打开所有检查，保证代码质量；在发布最终版本时，用 -O 选项将所有这些检查的开销降为零。
# if 语句做不到这一点，它的判断永远会执行，永远会产生性能开销。
# 关注点分离：区分“程序员的错误”和“程序的运行时错误”:
# assert 专门用来处理程序员的错误（Bugs）。
# 而 if/raise 用来处理程序的运行时错误（Runtime Errors），比如用户输入错误、文件没找到、网络中断等。
# 把这两种错误分开处理，会让错误处理逻辑更清晰。
# 遇到 AssertionError，知道是代码本身出了问题，需要回去修改代码。
# 遇到 ValueError, FileNotFoundError 等，你知道是外部环境或输入出了问题，程序应该根据逻辑（比如提示用户、重试）来妥善处理。
# try/except 和 if/raise 是同一阵营的战友，它们的目标都是处理程序的运行时错误，以保证程序的健壮性。
# 但它们是两种不同的策略和风格。
# 这两种策略在编程界通常被称为：
# LBYL (Look Before You Leap): “三思而后行”。这是 if 语句的风格。在执行一个可能会出错的操作之前，先进行检查。
# EAFP (Easier to Ask for Forgiveness than Permission): “先斩后奏，不行再补救”。
# 这是 try/except 的风格，也是Python社区更推崇的风格。直接尝试执行操作，如果出错了，再在 except 块中处理。
# 这种风格在 Python 中被认为是更优的，原因有二：
# 代码更简洁： 它将“正常流程”和“异常处理”清晰地分开了。try 块里是纯粹的正常逻辑。
# 性能可能更高： if 'key' in data: 这个检查本身也有开销。如果字典很大，或者 key 存在的概率很高，那么每次都检查就显得多余。
# EAFP风格只有在错误实际发生时才有额外开销。
# 当你处理的是“状态”检查时，if 更合适。
# 例如：if is_connected:，if age < 18:。
# 当你执行的操作本身就隐含了检查时，try/except (EAFP) 是首选。
# 例如类型转换: int(value)；
# 字典/列表访问: my_dict[key]；
# 文件操作: open('file.txt')；
# 对象属性访问: obj.attribute；
# 在这些情况下，你很难用 if 完美地预先检查所有可能的问题（文件存在但没权限读？值是字符串但不是数字格式？），所以直接 try 是最好、最全面的方式。

# 如果直接运行文件 test_name_function.py，将不会有任何输出，因为没有调用这个测试函数。
# 相反，应该让 pytest 替我们运行这个测试文件。
# 为此，打开一个终端窗口，并切换到这个测试文件所在的文件夹。
# 如果使用的是 VS Code，可打开测试文件所在的文件夹，并使用该编辑器内嵌的终端。
# 在终端窗口中执行命令 pytest，你将看到如下输出：
"""
$ pytest
=============================================================================================================================================== test session starts ===============================================================================================================================================
platform linux -- Python 3.11.9, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/luyucheng/learning/python-learning/python-crash-course
configfile: pyproject.toml
collected 1 item                                                                                                                                                                                                                                                                                                  

test_name_function.py .                                                                                                                                                                                                                                                                                     [100%]

================================================================================================================================================ 1 passed in 0.01s ================================================================================================================================================
"""
# 下面来尝试解读这些输出。首先，看到了一些有关运行测试的系统的信息。
# 最重要的是要注意，输出指出了用来运行该测试的 Python、pytest 和其他包的版本。
# 接下来，可以看到该测试是从哪个目录运行的，这里是 /home/luyucheng/learning/python-learning/python-crash-course。
# 也可以指定在特定的目录寻找测试文件。
# python-crash-course-3.11luyucheng@LAPTOP-TA9F45GS:~/learning/python-learning/python-crash-course/src/python_crash_course$ pdm run pytest ch11_testing_your_code/
# 输出完全一致。
# pytest 找到了一个测试，指出了运行的是哪个测试文件。
# 文件名后面的句点表明有一个测试通过了，而 100% 指出运行了所有的测试。
# 在可能有数百乃至数千个测试的大型项目中，句点和完成百分比有助于监控测试的运行进度。
# 最后一行指出有一个测试通过了，运行该测试花费的时间不到 0.01 秒。
# 上述输出表明，在给定包含名和姓的姓名时，get_formatted_name() 函数总是能正确地处理。
# 修改 get_formatted_name() 后，可再次运行这个测试。如果它通过了，就表明在给定 Janis Joplin 这样的姓名时，这个函数依然能够正确地处理。
# 注意：如果出现一条消息，提示没有找到命令 pytest，请执行命令 python -m pytest。

# 未通过的测试：测试未通过时的结果是什么样的呢？来修改 get_formatted_name()，使其能够处理中间名，但同时故意让这个函数无法正确地处理像 Janis Joplin 这样只有名和姓的姓名。
# 这个版本应该能够正确地处理包含中间名的姓名，但对其进行测试时，我们发现它不再能正确地处理只有名和姓的姓名了。
'''
$ pytest
========================================================================================================================================================== test session starts ==========================================================================================================================================================
platform linux -- Python 3.11.9, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/luyucheng/learning/python-learning/python-crash-course
configfile: pyproject.toml
collected 2 items                                                                                                                                                                                                                                                                                                                       

ch11_testing_your_code/test_name_function.py .F                                                                                                                                                                                                                                                                                   [100%]

=============================================================================================================================================================== FAILURES ================================================================================================================================================================
____________________________________________________________________________________________________________________________________________________ test_first_last_name_incorrect _____________________________________________________________________________________________________________________________________________________

    def test_first_last_name_incorrect():
        """能够正确地处理像 Janis Joplin 这样的姓名吗？"""
>       formatted_name = get_formatted_name_incorrect("janis", "joplin")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: get_formatted_name_incorrect() missing 1 required positional argument: 'last'

ch11_testing_your_code/test_name_function.py:12: TypeError
======================================================================================================================================================== short test summary info ========================================================================================================================================================
FAILED ch11_testing_your_code/test_name_function.py::test_first_last_name_incorrect - TypeError: get_formatted_name_incorrect() missing 1 required positional argument: 'last'
====================================================================================================================================================== 1 failed, 1 passed in 0.06s ======================================================================================================================================================
'''
# 这里的信息很多，因为在测试未通过时，需要知道的事情可能有很多。
# 首先，输出中有一个字母 F，表明有一个测试未通过。
# 然后是 FAILURES 部分，这是关注的焦点，因为在运行测试时，通常应该关注未通过的测试。
# 接下来，指出未通过的测试函数是 test_first_last_name()。
# 右尖括号指出了导致测试未能通过的代码行。
# 下一行中的 E 指出了导致测试未通过的具体错误：缺少必不可少的位置实参 'last'，导致 TypeError。
# 在末尾的简短小结中，再次列出了最重要的信息。
# 这样，即使你运行了很多测试，也可快速获悉哪些测试未通过以及测试未通过的原因。

# 在测试未通过时，该怎么办呢？如果检查的条件没错，那么测试通过意味着函数的行为是对的，而测试未通过意味着你编写的新代码有错。
# 因此，在测试未通过时，不要修改测试。
# 因为如果你这样做，即便能让测试通过，像测试那样调用函数的代码也将突然崩溃。
# 相反，应修复导致测试不能通过的代码：检查刚刚对函数所做的修改，找出这些修改是如何导致函数行为不符合预期的。
# 在这个示例中，get_formatted_name() 以前只需要名和姓这两个实参，但现在要求提供名、中间名和姓，而且新增的中间名参数是必不可少的。
# 这导致 get_formatted_name_incorrect() 的行为与原来不同。
# 就这里而言，最佳的选择是让中间名变为可选的。
# 这样，不仅在使用类似于 Janis Joplin 的姓名进行测试时可以通过，而且这个函数还能接受中间名。
# 下面来修改 get_formatted_name_incorrect()，将中间名设置为可选的，然后再次运行这个测试用例。
# 如果通过，就接着确认这个函数是否能够妥善地处理中间名。
# 要将中间名设置为可选的，可在函数定义中将形参 middle 移到形参列表末尾，并将其默认值指定为一个空字符串。
# 还需要添加一个 if 测试，以便根据是否提供了中间名相应地创建姓名：

# 在 get_formatted_name_correct() 的这个新版本中，中间名是可选的。
# 如果向这个函数传递了中间名，姓名将包含名、中间名和姓，否则将只包含名和姓。
# 现在，对于这两种不同的姓名，这个函数应该都能够正确地处理了。为了确定这个函数依然能够正确地处理像 Janis Joplin 这样的姓名，再次运行测试：
'''
========================================================================================================================================================== test session starts ==========================================================================================================================================================
platform linux -- Python 3.11.9, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/luyucheng/learning/python-learning/python-crash-course
configfile: pyproject.toml
collected 3 items                                                                                                                                                                                                                                                                                                                       

ch11_testing_your_code/test_name_function.py .F.                                                                                                                                                                                                                                                                                  [100%]

=============================================================================================================================================================== FAILURES ================================================================================================================================================================
____________________________________________________________________________________________________________________________________________________ test_first_last_name_incorrect _____________________________________________________________________________________________________________________________________________________

    def test_first_last_name_incorrect():
        """能够正确地处理像 Janis Joplin 这样的姓名吗？"""
>       formatted_name = get_formatted_name_incorrect("janis", "joplin")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: get_formatted_name_incorrect() missing 1 required positional argument: 'last'

ch11_testing_your_code/test_name_function.py:16: TypeError
======================================================================================================================================================== short test summary info ========================================================================================================================================================
FAILED ch11_testing_your_code/test_name_function.py::test_first_last_name_incorrect - TypeError: get_formatted_name_incorrect() missing 1 required positional argument: 'last'
====================================================================================================================================================== 1 failed, 2 passed in 0.05s ======================================================================================================================================================
'''
# 测试通过了。这意味着这个函数又能正确地处理像 Janis Joplin 这样的姓名了，无须手动测试这个函数。
# 因为未通过的测试帮我们识别出了新代码是如何破坏函数原有行为的，所以函数的修复工作变得更容易了。
# 添加新测试:确定 get_formatted_name_correct() 又能正确地处理简单的姓名后，再编写一个测试，用于测试包含中间名的姓名。
# 为此，在文件 test_name_function.py 中添加一个测试函数：
# 将这个新函数命名为 test_first_last_middle_name_correct()。
# 记住，函数名必须以 test_ 打头，这样该函数才会在我们运行 pytest 时自动运行。
# 这个函数名清楚地指出了它测试的是 get_formatted_name_correct() 的哪个行为，如果该测试未通过，就能马上知道受影响的是哪种类型的姓名。
# 为测试 get_formatted_name_correct() 函数，先使用名、姓和中间名调用它，再断言返回的姓名与预期的姓名（名、中间名和姓）一致.
'''
$ pytest
========================================================================================================================================================== test session starts ==========================================================================================================================================================
platform linux -- Python 3.11.9, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/luyucheng/learning/python-learning/python-crash-course
configfile: pyproject.toml
collected 4 items                                                                                                                                                                                                                                                                                                                       

ch11_testing_your_code/test_name_function.py .F..                                                                                                                                                                                                                                                                                 [100%]

=============================================================================================================================================================== FAILURES ================================================================================================================================================================
____________________________________________________________________________________________________________________________________________________ test_first_last_name_incorrect _____________________________________________________________________________________________________________________________________________________

    def test_first_last_name_incorrect():
        """能够正确地处理像 Janis Joplin 这样的姓名吗？"""
>       formatted_name = get_formatted_name_incorrect("janis", "joplin")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: get_formatted_name_incorrect() missing 1 required positional argument: 'last'

ch11_testing_your_code/test_name_function.py:16: TypeError
======================================================================================================================================================== short test summary info ========================================================================================================================================================
FAILED ch11_testing_your_code/test_name_function.py::test_first_last_name_incorrect - TypeError: get_formatted_name_incorrect() missing 1 required positional argument: 'last'
====================================================================================================================================================== 1 failed, 3 passed in 0.05s ======================================================================================================================================================
'''
# .F.. 代表有三个测试通过了，最后一行输出也清楚地指出了这一点。
# 现在知道，这个函数又能正确地处理像 Janis Joplin 这样的姓名了，而且确定它也能够正确地处理像 Wolfgang Amadeus Mozart 这样的姓名。
